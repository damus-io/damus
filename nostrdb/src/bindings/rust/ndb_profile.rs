// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

pub enum NdbProfileOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct NdbProfile<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for NdbProfile<'a> {
  type Inner = NdbProfile<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> NdbProfile<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_WEBSITE: flatbuffers::VOffsetT = 6;
  pub const VT_ABOUT: flatbuffers::VOffsetT = 8;
  pub const VT_LUD16: flatbuffers::VOffsetT = 10;
  pub const VT_BANNER: flatbuffers::VOffsetT = 12;
  pub const VT_DISPLAY_NAME: flatbuffers::VOffsetT = 14;
  pub const VT_REACTIONS: flatbuffers::VOffsetT = 16;
  pub const VT_PICTURE: flatbuffers::VOffsetT = 18;
  pub const VT_NIP05: flatbuffers::VOffsetT = 20;
  pub const VT_DAMUS_DONATION: flatbuffers::VOffsetT = 22;
  pub const VT_DAMUS_DONATION_V2: flatbuffers::VOffsetT = 24;
  pub const VT_LUD06: flatbuffers::VOffsetT = 26;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    NdbProfile { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args NdbProfileArgs<'args>
  ) -> flatbuffers::WIPOffset<NdbProfile<'bldr>> {
    let mut builder = NdbProfileBuilder::new(_fbb);
    if let Some(x) = args.lud06 { builder.add_lud06(x); }
    builder.add_damus_donation_v2(args.damus_donation_v2);
    builder.add_damus_donation(args.damus_donation);
    if let Some(x) = args.nip05 { builder.add_nip05(x); }
    if let Some(x) = args.picture { builder.add_picture(x); }
    if let Some(x) = args.display_name { builder.add_display_name(x); }
    if let Some(x) = args.banner { builder.add_banner(x); }
    if let Some(x) = args.lud16 { builder.add_lud16(x); }
    if let Some(x) = args.about { builder.add_about(x); }
    if let Some(x) = args.website { builder.add_website(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.add_reactions(args.reactions);
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(NdbProfile::VT_NAME, None)}
  }
  #[inline]
  pub fn website(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(NdbProfile::VT_WEBSITE, None)}
  }
  #[inline]
  pub fn about(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(NdbProfile::VT_ABOUT, None)}
  }
  #[inline]
  pub fn lud16(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(NdbProfile::VT_LUD16, None)}
  }
  #[inline]
  pub fn banner(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(NdbProfile::VT_BANNER, None)}
  }
  #[inline]
  pub fn display_name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(NdbProfile::VT_DISPLAY_NAME, None)}
  }
  #[inline]
  pub fn reactions(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(NdbProfile::VT_REACTIONS, Some(true)).unwrap()}
  }
  #[inline]
  pub fn picture(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(NdbProfile::VT_PICTURE, None)}
  }
  #[inline]
  pub fn nip05(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(NdbProfile::VT_NIP05, None)}
  }
  #[inline]
  pub fn damus_donation(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(NdbProfile::VT_DAMUS_DONATION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn damus_donation_v2(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(NdbProfile::VT_DAMUS_DONATION_V2, Some(0)).unwrap()}
  }
  #[inline]
  pub fn lud06(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(NdbProfile::VT_LUD06, None)}
  }
}

impl flatbuffers::Verifiable for NdbProfile<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("website", Self::VT_WEBSITE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("about", Self::VT_ABOUT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("lud16", Self::VT_LUD16, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("banner", Self::VT_BANNER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("display_name", Self::VT_DISPLAY_NAME, false)?
     .visit_field::<bool>("reactions", Self::VT_REACTIONS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("picture", Self::VT_PICTURE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("nip05", Self::VT_NIP05, false)?
     .visit_field::<i32>("damus_donation", Self::VT_DAMUS_DONATION, false)?
     .visit_field::<i32>("damus_donation_v2", Self::VT_DAMUS_DONATION_V2, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("lud06", Self::VT_LUD06, false)?
     .finish();
    Ok(())
  }
}
pub struct NdbProfileArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub website: Option<flatbuffers::WIPOffset<&'a str>>,
    pub about: Option<flatbuffers::WIPOffset<&'a str>>,
    pub lud16: Option<flatbuffers::WIPOffset<&'a str>>,
    pub banner: Option<flatbuffers::WIPOffset<&'a str>>,
    pub display_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub reactions: bool,
    pub picture: Option<flatbuffers::WIPOffset<&'a str>>,
    pub nip05: Option<flatbuffers::WIPOffset<&'a str>>,
    pub damus_donation: i32,
    pub damus_donation_v2: i32,
    pub lud06: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for NdbProfileArgs<'a> {
  #[inline]
  fn default() -> Self {
    NdbProfileArgs {
      name: None,
      website: None,
      about: None,
      lud16: None,
      banner: None,
      display_name: None,
      reactions: true,
      picture: None,
      nip05: None,
      damus_donation: 0,
      damus_donation_v2: 0,
      lud06: None,
    }
  }
}

pub struct NdbProfileBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> NdbProfileBuilder<'a, 'b> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NdbProfile::VT_NAME, name);
  }
  #[inline]
  pub fn add_website(&mut self, website: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NdbProfile::VT_WEBSITE, website);
  }
  #[inline]
  pub fn add_about(&mut self, about: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NdbProfile::VT_ABOUT, about);
  }
  #[inline]
  pub fn add_lud16(&mut self, lud16: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NdbProfile::VT_LUD16, lud16);
  }
  #[inline]
  pub fn add_banner(&mut self, banner: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NdbProfile::VT_BANNER, banner);
  }
  #[inline]
  pub fn add_display_name(&mut self, display_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NdbProfile::VT_DISPLAY_NAME, display_name);
  }
  #[inline]
  pub fn add_reactions(&mut self, reactions: bool) {
    self.fbb_.push_slot::<bool>(NdbProfile::VT_REACTIONS, reactions, true);
  }
  #[inline]
  pub fn add_picture(&mut self, picture: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NdbProfile::VT_PICTURE, picture);
  }
  #[inline]
  pub fn add_nip05(&mut self, nip05: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NdbProfile::VT_NIP05, nip05);
  }
  #[inline]
  pub fn add_damus_donation(&mut self, damus_donation: i32) {
    self.fbb_.push_slot::<i32>(NdbProfile::VT_DAMUS_DONATION, damus_donation, 0);
  }
  #[inline]
  pub fn add_damus_donation_v2(&mut self, damus_donation_v2: i32) {
    self.fbb_.push_slot::<i32>(NdbProfile::VT_DAMUS_DONATION_V2, damus_donation_v2, 0);
  }
  #[inline]
  pub fn add_lud06(&mut self, lud06: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NdbProfile::VT_LUD06, lud06);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> NdbProfileBuilder<'a, 'b> {
    let start = _fbb.start_table();
    NdbProfileBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<NdbProfile<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for NdbProfile<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("NdbProfile");
      ds.field("name", &self.name());
      ds.field("website", &self.website());
      ds.field("about", &self.about());
      ds.field("lud16", &self.lud16());
      ds.field("banner", &self.banner());
      ds.field("display_name", &self.display_name());
      ds.field("reactions", &self.reactions());
      ds.field("picture", &self.picture());
      ds.field("nip05", &self.nip05());
      ds.field("damus_donation", &self.damus_donation());
      ds.field("damus_donation_v2", &self.damus_donation_v2());
      ds.field("lud06", &self.lud06());
      ds.finish()
  }
}
pub enum NdbProfileRecordOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct NdbProfileRecord<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for NdbProfileRecord<'a> {
  type Inner = NdbProfileRecord<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> NdbProfileRecord<'a> {
  pub const VT_PROFILE: flatbuffers::VOffsetT = 4;
  pub const VT_RECEIVED_AT: flatbuffers::VOffsetT = 6;
  pub const VT_NOTE_KEY: flatbuffers::VOffsetT = 8;
  pub const VT_LNURL: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    NdbProfileRecord { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args NdbProfileRecordArgs<'args>
  ) -> flatbuffers::WIPOffset<NdbProfileRecord<'bldr>> {
    let mut builder = NdbProfileRecordBuilder::new(_fbb);
    builder.add_note_key(args.note_key);
    builder.add_received_at(args.received_at);
    if let Some(x) = args.lnurl { builder.add_lnurl(x); }
    if let Some(x) = args.profile { builder.add_profile(x); }
    builder.finish()
  }


  #[inline]
  pub fn profile(&self) -> Option<NdbProfile<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<NdbProfile>>(NdbProfileRecord::VT_PROFILE, None)}
  }
  #[inline]
  pub fn received_at(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(NdbProfileRecord::VT_RECEIVED_AT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn note_key(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(NdbProfileRecord::VT_NOTE_KEY, Some(0)).unwrap()}
  }
  #[inline]
  pub fn lnurl(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(NdbProfileRecord::VT_LNURL, None)}
  }
}

impl flatbuffers::Verifiable for NdbProfileRecord<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<NdbProfile>>("profile", Self::VT_PROFILE, false)?
     .visit_field::<u64>("received_at", Self::VT_RECEIVED_AT, false)?
     .visit_field::<u64>("note_key", Self::VT_NOTE_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("lnurl", Self::VT_LNURL, false)?
     .finish();
    Ok(())
  }
}
pub struct NdbProfileRecordArgs<'a> {
    pub profile: Option<flatbuffers::WIPOffset<NdbProfile<'a>>>,
    pub received_at: u64,
    pub note_key: u64,
    pub lnurl: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for NdbProfileRecordArgs<'a> {
  #[inline]
  fn default() -> Self {
    NdbProfileRecordArgs {
      profile: None,
      received_at: 0,
      note_key: 0,
      lnurl: None,
    }
  }
}

pub struct NdbProfileRecordBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> NdbProfileRecordBuilder<'a, 'b> {
  #[inline]
  pub fn add_profile(&mut self, profile: flatbuffers::WIPOffset<NdbProfile<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<NdbProfile>>(NdbProfileRecord::VT_PROFILE, profile);
  }
  #[inline]
  pub fn add_received_at(&mut self, received_at: u64) {
    self.fbb_.push_slot::<u64>(NdbProfileRecord::VT_RECEIVED_AT, received_at, 0);
  }
  #[inline]
  pub fn add_note_key(&mut self, note_key: u64) {
    self.fbb_.push_slot::<u64>(NdbProfileRecord::VT_NOTE_KEY, note_key, 0);
  }
  #[inline]
  pub fn add_lnurl(&mut self, lnurl: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(NdbProfileRecord::VT_LNURL, lnurl);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> NdbProfileRecordBuilder<'a, 'b> {
    let start = _fbb.start_table();
    NdbProfileRecordBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<NdbProfileRecord<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for NdbProfileRecord<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("NdbProfileRecord");
      ds.field("profile", &self.profile());
      ds.field("received_at", &self.received_at());
      ds.field("note_key", &self.note_key());
      ds.field("lnurl", &self.lnurl());
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `NdbProfileRecord`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_ndb_profile_record_unchecked`.
pub fn root_as_ndb_profile_record(buf: &[u8]) -> Result<NdbProfileRecord, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<NdbProfileRecord>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `NdbProfileRecord` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_ndb_profile_record_unchecked`.
pub fn size_prefixed_root_as_ndb_profile_record(buf: &[u8]) -> Result<NdbProfileRecord, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<NdbProfileRecord>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `NdbProfileRecord` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_ndb_profile_record_unchecked`.
pub fn root_as_ndb_profile_record_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<NdbProfileRecord<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<NdbProfileRecord<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `NdbProfileRecord` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_ndb_profile_record_unchecked`.
pub fn size_prefixed_root_as_ndb_profile_record_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<NdbProfileRecord<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<NdbProfileRecord<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a NdbProfileRecord and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `NdbProfileRecord`.
pub unsafe fn root_as_ndb_profile_record_unchecked(buf: &[u8]) -> NdbProfileRecord {
  flatbuffers::root_unchecked::<NdbProfileRecord>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed NdbProfileRecord and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `NdbProfileRecord`.
pub unsafe fn size_prefixed_root_as_ndb_profile_record_unchecked(buf: &[u8]) -> NdbProfileRecord {
  flatbuffers::size_prefixed_root_unchecked::<NdbProfileRecord>(buf)
}
#[inline]
pub fn finish_ndb_profile_record_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<NdbProfileRecord<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_ndb_profile_record_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<NdbProfileRecord<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
